package proxy

// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: addsvc.proto

/*
Package pb is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
//
//import (
//	//"io"
//	"net/http"
//
//	//"github.com/golang/protobuf/proto"
//	//"github.com/grpc-ecosystem/grpc-gateway/runtime"
//	//"github.com/grpc-ecosystem/grpc-gateway/utilities"
//	"golang.org/x/net/context"
//	"google.golang.org/grpc"
//	//"google.golang.org/grpc/codes"
//	"google.golang.org/grpc/grpclog"
//	//"google.golang.org/grpc/status"
//	//"net"
//	//"fmt"
//	//"github.com/gorilla/mux"
//	"net/url"
//	//"encoding/json"
//	"fmt"
//)
//
//
//type MyMux struct {
//	conn *grpc.ClientConn
//}
//
//type Args struct {
//	Form url.Values
//	Method string
//	Url *url.URL
//	Header http.Header
//}
//
//func (p *MyMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
//	//if r.URL.Path == "/" {
//	//	return
//	//}
//	//http.NotFound(w, r)
//	//endpoint := "localhost:8082"
//	// todo 这里应该用连接池
//	//args := Args{
//	//	Header:r.Header,
//	//	Method:r.Method,
//	//	Url:r.URL,
//	//	Form:r.Form,
//	//}
//
//	//grpc.NewClientStream()
//	var unaryStreamDesc = &grpc.StreamDesc{ServerStreams: false, ClientStreams: false}
//
//	cs, err := p.conn.NewStream(context.Background(), unaryStreamDesc, "/pb.Add/Sum")
//	if err != nil {
//		fmt.Printf("%v\n", err)
//		return
//	}
//	//cs.SendMsg()
//	if err := cs.SendMsg(req); err != nil {
//		//if !cs.c.failFast && cs.attempt.s.Unprocessed() && firstAttempt {
//		//	// TODO: Add a field to header for grpc-transparent-retry-attempts
//		//	firstAttempt = false
//		//	continue
//		//}
//		fmt.Printf("%v\n", err)
//		return// err
//	}
//	if err := cs.RecvMsg(reply); err != nil {
//		//if !cs.c.failFast && cs.attempt.s.Unprocessed() && firstAttempt {
//		//	// TODO: Add a field to header for grpc-transparent-retry-attempts
//		//	firstAttempt = false
//		//	continue
//		//}
//		//return err
//	}
//	return// nil
//
//
//
//	var out interface{}
//	p.conn.Invoke(context.Background(), "/pb.Add/Sum", nil, out)
//
//	//out := new(SumReply)
//	//err := grpc.Invoke(ctx, "/pb.Add/Sum", in, out, c.cc, opts...)
//	//if err != nil {
//	//	return nil, err
//	//}
//	//return out, nil
//	fmt.Printf("%+v", out)
//	w.Write([]byte("hello"))
//	return
//}
//
////var _ codes.Code
////var _ io.Reader
////var _ status.Status
////var _ = runtime.String
////var _ = utilities.NewDoubleArray
////
////func request_Add_Sum_0(ctx context.Context, marshaler runtime.Marshaler, client AddClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
////	var protoReq SumRequest
////	var metadata runtime.ServerMetadata
////
////	var (
////		val string
////		ok  bool
////		err error
////		_   = err
////	)
////
////	val, ok = pathParams["a"]
////	if !ok {
////		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "a")
////	}
////
////	protoReq.A, err = runtime.Int64(val)
////
////	if err != nil {
////		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "a", err)
////	}
////
////	val, ok = pathParams["b"]
////	if !ok {
////		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "b")
////	}
////
////	protoReq.B, err = runtime.Int64(val)
////
////	if err != nil {
////		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "b", err)
////	}
////
////	msg, err := client.Sum(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
////	return msg, metadata, err
////
////}
//
//
////type P struct{}
//
//
//// RegisterAddHandlerFromEndpoint is same as RegisterAddHandler but
//// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
//func RegisterHandlerFromEndpoint(ctx context.Context, address string, mux *MyMux, opts []grpc.DialOption) (err error) {
//	mux.conn, err = grpc.Dial(address, opts...)
//	if err != nil {
//		return
//	}
//	defer func() {
//		if err != nil {
//			if cerr := mux.conn.Close(); cerr != nil {
//				grpclog.Printf("Failed to close conn to %s: %v", address, cerr)
//			}
//			return
//		}
//		go func() {
//			<-ctx.Done()
//			if cerr := mux.conn.Close(); cerr != nil {
//				grpclog.Printf("Failed to close conn to %s: %v", address, cerr)
//			}
//		}()
//	}()
//
//	return
//}
//
//// RegisterAddHandler registers the http handlers for service Add to "mux".
//// The handlers forward requests to the grpc endpoint over "conn".
////func RegisterHandler(ctx context.Context, mux *MyMux, conn *grpc.ClientConn) error {
////	return RegisterAddHandlerClient(ctx, mux, NewAddClient(conn))
////}
//
//// RegisterAddHandler registers the http handlers for service Add to "mux".
//// The handlers forward requests to the grpc endpoint over the given implementation of "AddClient".
//// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "AddClient"
//// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
//// "AddClient" to call the correct interceptors.
////func RegisterAddHandlerClient(ctx context.Context, mux *runtime.ServeMux, client AddClient) error {
////	mux.Handle("GET", pattern_Add_Sum_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
////		ctx, cancel := context.WithCancel(req.Context())
////		defer cancel()
////		if cn, ok := w.(http.CloseNotifier); ok {
////			go func(done <-chan struct{}, closed <-chan bool) {
////				select {
////				case <-done:
////				case <-closed:
////					cancel()
////				}
////			}(ctx.Done(), cn.CloseNotify())
////		}
////		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
////		rctx, err := runtime.AnnotateContext(ctx, mux, req)
////		if err != nil {
////			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
////			return
////		}
////		resp, md, err := request_Add_Sum_0(rctx, inboundMarshaler, client, req, pathParams)
////		ctx = runtime.NewServerMetadataContext(ctx, md)
////		if err != nil {
////			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
////			return
////		}
////
////		forward_Add_Sum_0(ctx, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
////
////	})
////
////	return nil
////}
////
////var (
////	pattern_Add_Sum_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 1, 0, 4, 1, 5, 1, 1, 0, 4, 1, 5, 2}, []string{"sum", "a", "b"}, ""))
////)
////
////var (
////	forward_Add_Sum_0 = runtime.ForwardResponseMessage
////)
